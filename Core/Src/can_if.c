/**
 * @file    can_if.c
 * @brief   CAN interface layer for Mini ECU project.
 *
 * Project version history (high level):
 *   v1.0 - Basic timer + LED + UART logging.
 *   v1.1 - UART CLI (interrupt-driven RX).
 *   v2.0 - FreeRTOS tasks + CAN loopback telemetry.
 *   v2.1 - CAN_IF abstraction, RX queue, logging via CLI.
 *   v2.2 - VehicleState_t model + CAN telemetry encoding.
 */

#include "can_if.h"
#include <string.h>
#include <stdio.h>

/* External handles generated by CubeMX */
extern CAN_HandleTypeDef  hcan1;
extern UART_HandleTypeDef huart2;

/* --------------------------------------------------------------------------
 * Local helpers
 * -------------------------------------------------------------------------- */

static void can_uart_print(const char *s)
{
    HAL_UART_Transmit(&huart2, (uint8_t *)s, strlen(s), HAL_MAX_DELAY);
}

/* Logging flag: 0 = off, 1 = on (controlled from CLI) */
static uint8_t s_canLogEnabled = 0;

/* RX message queue handle */
static osMessageQueueId_t s_canRxQueue = NULL;

/* RX queue attributes (optional name for debugging) */
static const osMessageQueueAttr_t s_canRxQueueAttr = {
    .name = "CAN_RX_Queue"
};

/* --------------------------------------------------------------------------
 * Initialization
 * -------------------------------------------------------------------------- */

HAL_StatusTypeDef CAN_IF_Init(void)
{
    HAL_StatusTypeDef status;
    CAN_FilterTypeDef sFilterConfig;
    char dbg[128];

    /* Configure a simple "accept all" filter into FIFO0 */
    memset(&sFilterConfig, 0, sizeof(sFilterConfig));

    sFilterConfig.FilterBank           = 0;
    sFilterConfig.FilterMode           = CAN_FILTERMODE_IDMASK;
    sFilterConfig.FilterScale          = CAN_FILTERSCALE_32BIT;
    sFilterConfig.FilterIdHigh         = 0x0000;
    sFilterConfig.FilterIdLow          = 0x0000;
    sFilterConfig.FilterMaskIdHigh     = 0x0000;
    sFilterConfig.FilterMaskIdLow      = 0x0000;
    sFilterConfig.FilterFIFOAssignment = CAN_FILTER_FIFO0;
    sFilterConfig.FilterActivation     = ENABLE;
    sFilterConfig.SlaveStartFilterBank = 14;

    status = HAL_CAN_ConfigFilter(&hcan1, &sFilterConfig);
    snprintf(dbg, sizeof(dbg),
             "CAN_IF: ConfigFilter status=%ld err=0x%08lX\r\n",
             (long)status, (unsigned long)hcan1.ErrorCode);
    can_uart_print(dbg);
    if (status != HAL_OK)
    {
        return status;
    }

    /* Start CAN peripheral (must be in LOOPBACK mode for one-board demo) */
    status = HAL_CAN_Start(&hcan1);
    snprintf(dbg, sizeof(dbg),
             "CAN_IF: Start status=%ld state=%lu err=0x%08lX\r\n",
             (long)status,
             (unsigned long)hcan1.State,
             (unsigned long)hcan1.ErrorCode);
    can_uart_print(dbg);
    if (status != HAL_OK)
    {
        return status;
    }

    /* Enable CAN interrupts we care about:
       - RX FIFO0 message pending (for RX path)
       - Error notifications for debugging
       (TX mailboxes empty is not required for operation, only for notification)
    */
    status = HAL_CAN_ActivateNotification(
                 &hcan1,
                 CAN_IT_RX_FIFO0_MSG_PENDING |
                 CAN_IT_BUSOFF |
                 CAN_IT_ERROR |
                 CAN_IT_LAST_ERROR_CODE |
                 CAN_IT_ERROR_WARNING);

    snprintf(dbg, sizeof(dbg),
             "CAN_IF: ActivateNotification status=%ld err=0x%08lX\r\n",
             (long)status, (unsigned long)hcan1.ErrorCode);
    can_uart_print(dbg);
    if (status != HAL_OK)
    {
        return status;
    }

    /* Create RX message queue: up to 8 pending CAN messages */
    s_canRxQueue = osMessageQueueNew(8, sizeof(CAN_IF_Msg_t), &s_canRxQueueAttr);
    if (s_canRxQueue == NULL)
    {
        can_uart_print("CAN_IF: Failed to create RX queue\r\n");
        return HAL_ERROR;
    }

    return HAL_OK;
}

/* --------------------------------------------------------------------------
 * Telemetry transmit helper
 * -------------------------------------------------------------------------- */

HAL_StatusTypeDef CAN_IF_SendTelemetry(const VehicleState_t *vs)
{
    if (vs == NULL)
    {
        return HAL_ERROR;
    }

    CAN_TxHeaderTypeDef txHeader;
    uint8_t  data[8] = {0};
    uint32_t mailbox;
    HAL_StatusTypeDef st;

    memset(&txHeader, 0, sizeof(txHeader));

    /* Pack vehicle state:
       - speed_kph * 10 (uint16)
       - engine_rpm (uint16)
       - coolant_temp_c * 10 (int16)
    */
    uint16_t speed10 = (uint16_t)(vs->speed_kph * 10.0f);
    int16_t  temp10  = (int16_t)(vs->coolant_temp_c * 10.0f);

    data[0] = (uint8_t)(speed10 >> 8);
    data[1] = (uint8_t)(speed10 & 0xFF);

    data[2] = (uint8_t)(vs->engine_rpm >> 8);
    data[3] = (uint8_t)(vs->engine_rpm & 0xFF);

    data[4] = (uint8_t)(temp10 >> 8);
    data[5] = (uint8_t)(temp10 & 0xFF);

    txHeader.StdId = 0x100U;
    txHeader.ExtId = 0U;
    txHeader.IDE   = CAN_ID_STD;
    txHeader.RTR   = CAN_RTR_DATA;
    txHeader.DLC   = 6U;
    txHeader.TransmitGlobalTime = DISABLE;

    st = HAL_CAN_AddTxMessage(&hcan1, &txHeader, data, &mailbox);

    if (st != HAL_OK)
    {
        /* Debug TX path: show state, error code and mailbox free level */
        char buf[160];
        uint32_t free = HAL_CAN_GetTxMailboxesFreeLevel(&hcan1);
        snprintf(buf, sizeof(buf),
                 "TX FAIL: st=%ld state=%lu err=0x%08lX free=%lu\r\n",
                 (long)st,
                 (unsigned long)hcan1.State,
                 (unsigned long)hcan1.ErrorCode,
                 (unsigned long)free);
        HAL_UART_Transmit(&huart2, (uint8_t *)buf, strlen(buf), HAL_MAX_DELAY);
    }

    return st;
}

/* --------------------------------------------------------------------------
 * Logging control / queue accessor
 * -------------------------------------------------------------------------- */

void CAN_IF_SetLogging(uint8_t enable)
{
    s_canLogEnabled = (enable ? 1U : 0U);
}

osMessageQueueId_t CAN_IF_GetRxQueueHandle(void)
{
    return s_canRxQueue;
}

/* --------------------------------------------------------------------------
 * RX message processing (called from RTOS task)
 * -------------------------------------------------------------------------- */

void CAN_IF_ProcessRxMsg(const CAN_IF_Msg_t *msg)
{
    if (msg == NULL)
    {
        return;
    }

    if (!s_canLogEnabled)
    {
        return;
    }

    char buf[128];
    int len = snprintf(buf, sizeof(buf),
                       "CAN RX: ID=0x%03lX DLC=%u Data=",
                       (unsigned long)msg->id,
                       (unsigned int)msg->dlc);
    HAL_UART_Transmit(&huart2, (uint8_t *)buf, len, HAL_MAX_DELAY);

    for (uint8_t i = 0; i < msg->dlc; i++)
    {
        len = snprintf(buf, sizeof(buf), "%02X ", msg->data[i]);
        HAL_UART_Transmit(&huart2, (uint8_t *)buf, len, HAL_MAX_DELAY);
    }
    can_uart_print("\r\n");
}

/* --------------------------------------------------------------------------
 * HAL callbacks
 * -------------------------------------------------------------------------- */

/* RX FIFO0 pending: called in interrupt context */
void HAL_CAN_RxFifo0MsgPendingCallback(CAN_HandleTypeDef *hcan)
{
    if (hcan->Instance != CAN1)
    {
        return;
    }

    CAN_RxHeaderTypeDef rxHeader;
    uint8_t data[8];

    if (HAL_CAN_GetRxMessage(hcan, CAN_RX_FIFO0, &rxHeader, data) != HAL_OK)
    {
        return;
    }

    if (s_canRxQueue == NULL)
    {
        return;
    }

    CAN_IF_Msg_t msg;
    msg.id  = rxHeader.StdId;
    msg.dlc = rxHeader.DLC;
    memset(msg.data, 0, sizeof(msg.data));
    memcpy(msg.data, data, rxHeader.DLC);

    /* Drop on full queue rather than blocking in ISR */
    (void)osMessageQueuePut(s_canRxQueue, &msg, 0, 0);
}

/* Optional TX-complete callbacks.
   Not required for freeing mailboxes (hardware does that),
   but useful if you want to add debug prints later.
*/
void HAL_CAN_TxMailbox0CompleteCallback(CAN_HandleTypeDef *hcan)
{
    (void)hcan;
}

void HAL_CAN_TxMailbox1CompleteCallback(CAN_HandleTypeDef *hcan)
{
    (void)hcan;
}

void HAL_CAN_TxMailbox2CompleteCallback(CAN_HandleTypeDef *hcan)
{
    (void)hcan;
}
